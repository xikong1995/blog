Web 性能优化是一个老生常谈的问题，以前看了很多零碎的知识，所以一直想找个机会好好总结一下。Web 性能优化涉及的面很广，这里我从前端的视角讲一讲优化点，主要分为传输层和渲染层。

这篇文章，我讲述的是浏览器的渲染流程。

# 浏览器渲染流程

## 浏览器架构
在介绍浏览器渲染流程之前，我们先来简单看一看浏览器的架构。这里我主要介绍 Chrome 的架构，毕竟它目前全球占有率第一。

现代浏览器采用的多进程架构，避免单进程导致的不稳定、不流畅、不安全的问题。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201213164022163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob3VsZWkxOTk1,size_16,color_FFFFFF,t_70#pic_center)

当我们打开浏览器时，浏览器至少会开启 4 个进程。其中浏览器主进程、网络进程、GPU 进程是所有 Tab（标签） 页共用。一般每一个 Tab 页会有一个独立的渲染进程，当然也有例外的情况，这里不展开讲了。

- **浏览器进程：** 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **GPU 进程：** 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- **网络进程：** 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- **渲染进程：** 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

## 渲染流程
当我们在浏览器地址栏输入一个页面地址后，浏览器就会想服务器发送一个请求。请求成功后，我们就可以拿到页面内容。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020121316511782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob3VsZWkxOTk1,size_16,color_FFFFFF,t_70#pic_center)

大致分为三大步骤：
1. 构建 DOM 树；
2. 样式计算；
3. 布局阶段。

值得注意的是布局阶段十分复杂，又可以分为如下几个阶段：
- 分层
- 绘制
- 分块
- 光栅化
- 合成显示

## 重排、重绘与合成

**重排**

如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

**重绘**

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

**合成**

我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

# 渲染层优化
这里写到的优化策略主要是从**用户体验出发**，针对浏览器的渲染机制来制定的。

## 渲染路径优化
主要是**避免阻塞**、**减少重排**和**减少重绘**。

- CSS 放在 header，而 JavaScript 放在 body 底部
- 采用异步请求获取数据
- 避免逐项更改样式。最好一次性更改 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
- 避免循环操作 DOM。创建一个document Fragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到window.document
- 避免循环读取偏移量（offset）、滚动位置（scroll values）等属性。在循环之前把它们存起来
- 减少字体的改变，会造成大面积的 reflow 和 repaint

## HTML 优化
- 避免表格布局：表格布局会阻断页面逐步渲染，它需要整个表格结构都解析完才去渲染
- 避免使用 iframe：iframe 是开销最高的 DOM 元素，并且会阻塞 onload 事件

## 图像优化
- 选择合适的图片格式：PNG 一般会比 JPG 格式要大，如果不需要支持透明图片，可以选择 JPG 格式
- 图片懒加载：避免下载当前无用的资源，节省网络开销
- 避免对图像进行缩放：如果我们img标签设置的图片宽高和真实图片大小不一致，这个时候会导致 CUP 进行额外的缩放计算

## CSS 优化
- 简化 CSS 选择符
- 动画使用 transform 和 opacity：当我们修改元素的这两个属性之一时，浏览器就会把元素提升到其自己的绘制图层并使用 GPU 加速
- 让动画元素脱离文档流：通过绝对定位，让动画元素脱离文档流，在动画结束后，再恢复定位。脱离文档流会独立创建渲染层，这样不会触发大面积重排和重绘

## JavaScript 优化
- 减少作用域深度：作用域深度越深，那么 JS 执行会越慢
- 将需要频繁存取的值存储到局部变量中
- 两个条件可以判断出现概率的流程优先使用 if ，而多个条件无法判断出现概率的流程优先使用 switch
- 使用 Web Worker 处理耗时操作
- 使用函数防抖处理高频触发的事件

## 内存优化
- 对于大量绑定事件的场景可以采用事件委托
- 使用虚拟列表优化长列表

# 总结
渲染层的优化主要是根据浏览器的渲染引擎和执行引擎的运行机制来做的，这个是根本原则。可能很多人在网上搜索性能优化相关资料时，只是简单看了该做什么可以优化性能。但是到底为什么要这样做，却被大家忽略了。

如果我们只知道要做是什么这种表象的东西，那么有时可能适得其反。如果哪天浏览器的渲染机制改变了呢？那我们目前掌握的优化手段是不是也要相应的做出改变？

本文只是个人简单的学习笔记，难免会出现错误，希望读到本文的同学仅仅把其作为参考。另外参考书里有些内容是过时了（比如去掉字符串空格等），不过一些细节还是值得学习的。

---

参考：
- [浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)
- [高性能网站建设指南](https://book.douban.com/subject/3132277/)
- [高性能网站建设进阶指南](https://book.douban.com/subject/4719162/)
- [高性能JavaScript](https://book.douban.com/subject/26599677/)
